[{"title":"推荐我在Mac上常用的软件和网站","url":"/2018/11/16/推荐我在Mac上常用的软件和网站/","content":"\n上个周末入手了一台新的 iMac，花了半天时间把自己常用的软件装了上去，正好趁这个机会写一篇关于Mac常用软件分享的文章，希望对大家能有所帮助。\n\n## 生活类软件：\n\n### 1.Flux\n\n![](/images/推荐我在Mac上常用的软件/生活类/001.png){:height=\"50\" width=\"50\"}\n\n保护视力的一个App，能自动调节屏幕的亮度和色彩，用了很多年。平时打开，关闭这个App的时候眼睛感觉挺明显。\n\n### 2.Pap.er\n\n![](/images/推荐我在Mac上常用的软件/生活类/002.png)\n\n一款壁纸App，里面的壁纸挺漂亮。交互也比较简单，是我用过的几款相似软件中比较出众的。\n\n### 3.iTranslate\n\n![](/images/推荐我在Mac上常用的软件/生活类/003.png)\n\n![](/images/推荐我在Mac上常用的软件/生活类/004.png)\n\n一款比较好用的翻译App。推荐它的原因是在Mac顶部状态栏里打开就能用，平时遇到单词可以顺手查一下，比单独打开谷歌翻译的速度要快一点。\n\n### 4.印象笔记 Evernote\n\n![](/images/推荐我在Mac上常用的软件/生活类/005.png)\n\n![](/images/推荐我在Mac上常用的软件/生活类/006.png)\n\n每天都会用到的App，有什么想法和灵感都会记录在这上面。养成每日记录和写文字的习惯，支持 iPhone和 Mac上的内容同步。\n\n### 5.Things3\n\n![](/images/推荐我在Mac上常用的软件/生活类/007.png)\n\n![](/images/推荐我在Mac上常用的软件/生活类/008.png)\n\n一款To-Do类应用，非常推荐。每天早上都会想好今天每个时间段做什么事情，并在上面记录下来，晚上的时候给完成的事打勾，可以让我们每天过的明白一点，知道什么时候做什么事情。\n\n### 6.YoMail\n\n![](/images/推荐我在Mac上常用的软件/生活类/010.png)\n\n一款好用的邮件客户端，比开网页邮件端要好。\n\n### 7.Google Chrome Canary\n\n![](/images/推荐我在Mac上常用的软件/生活类/011.png)\n\n谷歌浏览器的开发版本，用起来比普通版本的感觉要好。之前用了很长时间Mac自带的浏览器Safari，现在在用这个浏览器。两个各有优点，更推荐Google Chrome Canary。\n\n### 8. QQ & 微信\n\n![](/images/推荐我在Mac上常用的软件/生活类/012.png)\n\n![](/images/推荐我在Mac上常用的软件/生活类/015.png)\n\n必备的App。\n\n### 9.SpechtLite\n\n![](/images/推荐我在Mac上常用的软件/生活类/014.png)\n\n这个可以自己搜索了解一下。\n\n### 10.Dr Cleaner\n\n![](/images/推荐我在Mac上常用的软件/生活类/013.png)\n\n好用的免费Mac清理软件，平时使用足够了。（收费版的CleanMyMac之前有一次把电脑清崩溃了…）\n\n\n## 开发类软件： \n\n### 1.Xcode\n\n![](/images/推荐我在Mac上常用的软件/开发类/001.png)\n\n用 Xcode和 Android Studio来开发 iOS和 Android应用，总感觉 Xcode用起来更优雅一点。\n\n### 2.Android Studio\n\n![](/images/推荐我在Mac上常用的软件/开发类/002.png)\n\n开发Android App首选。\n\n### 3.iTerm\n\n![](/images/推荐我在Mac上常用的软件/开发类/004.png)\n\n比 Mac自带的终端更好用。\n\n### 4.SourceTree\n\n![](/images/推荐我在Mac上常用的软件/开发类/005.png)\n\nGit 的客户端管理工具，属于开发必备的工具，代码管理的神器。\n\n### 5.图标构建\n\n![](/images/推荐我在Mac上常用的软件/开发类/006.png)\n\n很好用的Appicon 自动生成所有分辨率类型的App，开发必备。","tags":["原创","生活"],"categories":["生活"]},{"title":"RosJava环境搭建","url":"/2018/11/12/ROSJava环境搭建/","content":"\nROS (Robot Operating System) 是在2010年发布的开源机器人操作系统。\n\nRosJava 是用 Java实现的 ROS，它提供了一个客户端库用于快速调用 ROS的 Topics, Services 和Parameters，我们可以用它在 Android 上进行 RosJava的开发。\n\n资料分享: Ros官网: http://wiki.ros.org/\n\t\tRosJava官方文档: http://wiki.ros.org/rosjava\n\n\n## 1.ROS环境搭建\nROS Kinetic支持 Xenial (16.04)和 Wily(15.10)，其它 Linux 系统需要安装其它的 ROS版本。\n下面开始在 Ubuntu 16.0.4上搭建 ROS Kinetic开发环境。\n\n参考资料: http://wiki.ros.org/kinetic\n\t\t  http://wiki.ros.org/kinetic/Installation/Ubuntu\n\n### 使用下面命令：\n\n    ~$ sudo sh -c 'echo \"deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main\" > /etc/apt/sources.list.d/ros-latest.list'\n    \n![](/images/ROSJava环境搭建/001.png)\n\n2.2 设置keys\n\n    ~$ sudo apt-key adv --keyserver hkp://ha.pool.sks-keyservers.net:80 --recv-key 0xB01FA116\n\n![](/images/ROSJava环境搭建/002.png)\n\n2.3 安装\n\n    ~$ sudo apt-get update\n\n    ~$ sudo apt-get install ros-kinetic-desktop-full\n\n安装功能包：\n\n    ~$ sudo apt-get install ros-kinetic-slam-gmapping\n\n查找在kinetic中可以使用的功能包：\n\n    ~$ apt-cache search ros-kinetic\n\n2.4 初始化\n\n    ~$ sudo rosdep init\n\n    ~$ rosdep update\n\n2.5 环境配置\n\n    ~$ echo \"source /opt/ros/kinetic/setup.bash\" >> ~/.bashrc\n\n    ~$ source ~/.bashrc\n\n注意当安装多个ROS发行版，使用kinetic需要用到下面命令：\n\n    ~$ source /opt/ros/kinetic/setup.bash\n\n2.6 安装rosinstall\n\n    ~$ sudo apt-get install python-rosinstall\n\n2.7 测试roscore\n\n    ~$ roscore\n\n![](/images/ROSJava环境搭建/003.png)\n\n\n安装ROS成功后,在Beginner Tutorials中有一个简单的示例程序.\n\n![](/images/ROSJava环境搭建/004.png)\n\n\n在Terminal中运行以下命令： \n\n    $ roscore\n\n新开一个terminal，运行以下命令，打开小乌龟窗口： \n\n    $ rosrun turtlesim turtlesim_node\n\n\n新开一个terminal，运行以下命令，打开乌龟控制窗口，可使用方向键控制乌龟运动： \n\n\n    $ rosrun turtlesim turtle_teleop_key\n\n\n选中控制窗口，按方向键，可看到小乌龟窗口中乌龟在运动。\n新开一个terminal，运行以下命令，可以看到ROS的图形化界面，展示结点的关系： \n\n\n    $ rosrun rqt_graph rqt_graph\n\n至此，测试完成，ROS成功\n\n\n\n2.RosJava环境搭建 \n\n在 Ros环境搭建完成后搭建 RosJava 环境。\n\n参考资料: http://wiki.ros.org/rosjava/Tutorials/kinetic/Source%20Installation\n\t\t  https://blog.csdn.net/F_season/article/details/9166133\n\n使用下面命令：\n1.安装依赖\n$ sudo apt-get install ros-kinetic-catkin ros-kinetic-rospack python-wstool openjdk-8-jdk\n\n2.核心功能\n$ mkdir -p ~/rosjava/src\n$ wstool init -j4 ~/rosjava/src https://raw.githubusercontent.com/rosjava/rosjava/kinetic/rosjava.rosinstall\n$  source /opt/ros/kinetic/setup.bash\n$  cd ~/rosjava\n$  rosdep update\n$  rosdep install --from-paths src -i -y\n$  catkin_make\n\n3.配置 .bashrc文件\n在.bashrc 文件里设置 Ros的环境变量，不设置的话 ROS和 RosJava Android\n间的通讯不能连通。\n\nLinux系统里打开终端，输入命令:\n$ gedit ~/.bashrc\n\n![](/images/ROSJava环境搭建/005.png)\n\n在最后一行添加三个 export语句\nexport ROS_HOSTNAME=192.168.199.141\nexport ROS_IP=192.168.199.141\nexport ROS_MASTER_URL=http://192.168.199.141:11311\n\n把IP地址改成自己本机连接网络的IP地址，之后手机和安装Linux的ROS系统需要连接在同一个网络\n\n\n3.在 Android中使用ROS\n在Mac上搭建好 Android开发环境，安装好Android Studio，配置好翻墙网络。\n通过给Android App添加上ROS的依赖库，可以在没有ROS环境的Mac上开发ROS客户端。\n\n参考资料:\nhttp://community.bwbot.org/topic/627/%E5%9C%A8android%E4%B8%AD%E4%BD%BF%E7%94%A8ros\n\n1.创建一个 Android App项目\n\n![](/images/ROSJava环境搭建/006.png)\n\n![](/images/ROSJava环境搭建/007.png)\n\n然后点击Finish\n\n等待项目同步完成。一般这里出问题就是网络没有配置好，需要开翻墙软件。\n\n\n2.修改 build.gradle文件\n\n项目同步完成之后，在项目左侧的文件列表内会有两个build.gradle文件。其中一个是Project的，另一个是Module的。\n\n![](/images/ROSJava环境搭建/008.png)\n\n首先修改Project的build.gradle文件\n\n把文件中的\n\nbuildscript {\n    repositories {\n        jcenter()\n    }\n    dependencies {\n        classpath 'com.android.tools.build:gradle:2.2.3'\n\n        // NOTE: Do not place your application dependencies here; they belong\n        // in the individual module build.gradle files\n    }\n}\n修改为\n\nbuildscript {\n  apply from: \"https://github.com/rosjava/android_core/raw/kinetic/buildscript.gradle\"\n}\n然后在文件中添加\n\nsubprojects {\n    apply plugin: 'ros-android'\nDo not place your applica\n    afterEvaluate { project ->\n        android {\n            // Exclude a few files that are duplicated across our dependencies and\n            // prevent packaging Android applications.\n            packagingOptions {\n                exclude \"META-INF/LICENSE.txt\"\n                exclude \"META-INF/NOTICE.txt\"\n            }\n        }\n    }\n}\n然后修改Module的build.gradle，在dependencies 中添加ros依赖\n\n...\ndependencies {\n    ...\n    // You now now add any rosjava dependencies, like so:\n    compile 'org.ros.android_core:android_10:[0.3,0.4)'\n}\n...\n同时把dependencies 中的 全部implementation修改为compile。注意修改时的大小写。\n\n把文件中的compileSdkVersion版本设置为25\ntargetSdkVersion也设置为25\n把 com.android.support:appcompat-v7:27.1.1也修改成25的版本\n\n最后修改完成的文件如下面所示\n\napply plugin: 'com.android.application'\n\nandroid {\n    compileSdkVersion 25\n    defaultConfig {\n        applicationId \"org.bwbot.rostest\"\n        minSdkVersion 15\n        targetSdkVersion 25\n        versionCode 1\n        versionName \"1.0\"\n        testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\"\n    }\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n        }\n    }\n}\n\ndependencies {\n    compile fileTree(dir: 'libs', include: ['*.jar'])\n    compile 'com.android.support:appcompat-v7:25.4.0'\n    compile 'com.android.support.constraint:constraint-layout:1.1.3'\n    testCompile 'junit:junit:4.12'\n    androidTestCompile 'com.android.support.test:runner:1.0.2'\n    androidTestCompile 'com.android.support.test.espresso:espresso-core:3.0.2'\n    compile 'org.ros.android_core:android_10:[0.3,0.4)'\n}\n\n3.修改AndroidManifest.xml文件\n此时如果编译项目会出现下面的错误\n\nManifest merger failed : Attribute application@icon value=(@mipmap/ic_launcher) from AndroidManifest.xml:7:9-43\n\tis also present at [org.ros.android_core:android_10:0.3.3] AndroidManifest.xml:19:9-36 value=(@mipmap/icon).\n\tSuggestion: add 'tools:replace=\"android:icon\"' to <application> element at AndroidManifest.xml:5:5-19:19 to override.\n此时需要修改AndroidManifest.xml文件在application项目中做如下修改\n\n<application xmlns:tools=\"http://schemas.android.com/tools\"\n        tools:replace=\"android:icon\"\n        ...\n为了能够正常使用还需要给app添加网络权限。在AndroidManifest.xml文件中添加\n\n<uses-permission android:name=\"android.permission.INTERNET\"/>\n最后的AndroidManifest.xml文件如下\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"org.bwbot.rostest\">\n    <uses-permission android:name=\"android.permission.INTERNET\"/>\n    <application\n        xmlns:tools=\"http://schemas.android.com/tools\"\n        tools:replace=\"android:icon\"\n        android:allowBackup=\"true\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\n        android:supportsRtl=\"true\"\n        android:theme=\"@style/AppTheme\">\n        <activity android:name=\".MainActivity\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n        </activity>\n    </application>\n</manifest>\n此时项目已经可以成功编译了。\n\n2. 写一个简单的消息发布程序\nMainActivity.java内容如下\n\npackage org.bwbot.rostest;\n\nimport android.support.v7.app.AppCompatActivity;\nimport android.os.Bundle;\n\nimport org.ros.android.RosActivity;\nimport org.ros.concurrent.CancellableLoop;\nimport org.ros.namespace.GraphName;\nimport org.ros.node.ConnectedNode;\nimport org.ros.node.Node;\nimport org.ros.node.NodeConfiguration;\nimport org.ros.node.NodeMain;\nimport org.ros.node.NodeMainExecutor;\nimport org.ros.node.topic.Publisher;\n\nimport java.net.URI;\n\nimport std_msgs.String;\n\npublic class MainActivity extends RosActivity {\n\n    protected MainActivity() {\n        super(\"ros_test\", \"ros_test\", URI.create(\"http://192.168.0.23:11311\")); // 这里是ROS_MASTER_URI\n    }\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n    }\n\n    @Override\n    protected void init(NodeMainExecutor nodeMainExecutor) {\n        NodeConfiguration nodeConfiguration = NodeConfiguration.newPublic(getRosHostname());\n        nodeConfiguration.setMasterUri(getMasterUri());\n        nodeMainExecutor.execute(new NodeMain() {\n            @Override\n            public GraphName getDefaultNodeName() {\n                return GraphName.of(\"ros_test\");\n            }\n\n            @Override\n            public void onStart(ConnectedNode connectedNode) {\n                final Publisher<std_msgs.String> pub =  connectedNode.newPublisher(\"/test\", String._TYPE);\n                connectedNode.executeCancellableLoop(new CancellableLoop() {\n                    @Override\n                    protected void loop() throws InterruptedException {\n                        std_msgs.String msg = pub.newMessage();\n                        msg.setData(\"hello world\");\n                        pub.publish(msg);\n                        Thread.sleep(1000);\n                    }\n                });\n            }\n\n            @Override\n            public void onShutdown(Node node) {\n\n            }\n\n            @Override\n            public void onShutdownComplete(Node node) {\n\n            }\n\n            @Override\n            public void onError(Node node, Throwable throwable) {\n\n            }\n        }, nodeConfiguration);\n    }\n}\n\n编译后，在手机上运行App，在运行的ROS的主机上打印/test话题。\n\n手机要和Linux机器连接在同一个 Wi-Fi下，Linux上已修改 .bashrc文件，添加本机 IP。\nAndroid程序中已配置ROS_MASTER_URL 地址。\n\n在 Linux 上新开一个 Terminal中运行以下命令： \n$ roscore\n新开一个terminal，cd 到 rosjava文件夹中，运行命令:\n$ ros topic echo /test\n\n![](/images/ROSJava环境搭建/009.png)\n\n可以看到消息已经成功发送出来了。\n到这Anroid端和Linux端的ROS通讯成功。\n","tags":["原创","技术"],"categories":["开发"]},{"title":"Some feature of Objective-C","url":"/2018/08/12/SomefeatureofObjective-C/","content":"\n## 1.AppDelegate.h and AppDelegate.m\nWhen the application is created there are AppDelegate.h files and AppDelegate.m files by default. AppDelegateis a proxy for the whole application, it provides a monitoring interface to setting the program when it’s in the start, background, exit and active.\n\n## 2.Class methods and instance methods\nThere are two types of methods in Objective-C: class methods and instance methods. Like “ - (void) setnumber: (int) n; “ that begin with symbol “-“ means that the\nmethod is an instance methods. Instance methods are some of the operations performed on a particular instance of a class. For example, there is a white rabbit, it’s weight has increasted. We can define a instanse methods of weught to reflect the weight change of the white rabbit.\n\nClass methods are some of the operations performed on the class itself. For example, we create a new calss, this method is class methods.\n\n\n\n\n\n\n\n","tags":["原创","技术"],"categories":["开发"]},{"title":"Android 入门教程","url":"/2018/07/23/入门教程/","content":"\n这篇文章总结了我在学习 Android过程中获得的经验、资源和代码。\n用这篇文章作为 Android学习结束的技术文档，自己总结一遍的同时，\n希望能帮到看这篇文档的人。\n\n## 1.基础知识入门\n\n这里首推谷歌的开发者文档，其中部分文档已经有中文版的，读起来很方便。\nhttps://developer.android.com/guide/\n\n也有中文版的 Android官方培训课程，可以对照着谷歌的文档一起看。\nhttp://hukai.me/android-training-course-in-chinese/index.html\n\n看官方文档推荐挑着看，如可以先读\n1.1 建立第一个App ；\n1.2添加ActionBar； \n1.4管理Activity的生命周期；\n1.5 使用Fragment建立动态UI； \n1.6数据保存； \n1.7与其它应用的交互等基础\n这些基础章节的内容看完后，整个Android App的运行机制大概就有了解了，剩下几个大章的文档\n就是各种细节的实现。等需要做哪部分功能的时候，再看相应的文档。\n\n其它的一些资源推荐：\na. 开发Android用的 Java文档\nhttp://www.runoob.com/java/java-methods.html\n现在Android开发可以使用 Java和 Kotlin，考虑到Java使用的广泛性，推荐使用Java来入门Android和\n开发公司的App，Kotlin可以之后开发个人App的时候使用。\n\nb.Android Fragment使用详解\nhttps://juejin.im/post/5a926630f265da4e8c45264e\n通过这篇文章可以了解下 Fragment和它的生命周期内容\n\nc.Android 的 mvp分层架构\nhttp://www.androidchina.net/8195.html\n了解下 Android的mvp架构，先有个印象。\n\nd.Android的按键消息分发机制\nhttps://www.jianshu.com/p/0c80cdb37af8\n通过这篇文章可以了解Android的按键消息分发机制，了解App在按键过程中的运行流程。\n\ne.记7月份Android面试感想\nhttps://juejin.im/post/5b67ca1c518825625529b2fb\n常见的Android面试题，面试中能问到的Android问题都是比较经典的，通过面试的问题\n来学习Android 中一些重要的知识点。\n\n### 说明：\n在上面分享 Android基础知识的资源，官方文档挑着看完之后就应该写代码了，\n首先根据官方文档先写出一个简单的App，之后再写稍微复杂一点的App。\n其它推荐的资源是边写代码有疑问的时候看的。\n不要等全部资料看完了再写代码，需要注意这个顺序。\n\n### 注意:\n\n上面的一些教程默认是翻墙的环境，并安装好了 Android Studio\n\n同步Android Studio过程中的大部分问题都与网络有关，搞定网络问题(翻墙)就解决了一大半问题。\n\n关于Android Studio的资料：\nhttp://wiki.jikexueyuan.com/project/android-studio-guide/\n\n## 2.Android代码实践\n完成了上面的基础教程，下一步就准备写代码。\n(看别人的源码理解太浅，要自己写才能发现实际的问题）\n\n这里给出一个实际的很简单的需求：\n\n新开封的盒装牛奶和放在咖啡机里的牛奶容易过期，现在做\n一个Android App来记录开牛奶和往咖啡机里加牛奶的时间，\n并显示当前的日期，能让看的人知道当前的牛奶是否过期了。\n\n分析：\n1.需要两个Button，点击后可以再两个对应的Label上显示当前\n的日期和时间，精确到秒。\n2.还有一个Label来显示当前的实时时间。\n3.UI自己设计，能做的美观大方最好。\n\n通过分享可以知道这是一个很简单的AndroidA pp，尝试自己来完成。\n\n这里有开源的App，可以参考着写：\nhttp://gitlab.mynt.com/NanJun/MilkCoffee","tags":["原创","技术"],"categories":["开发"]},{"title":"Vysor破解过程记录","url":"/2018/05/12/Vysor破解过程记录/","content":"\n最近需要用到到 Vysor，走 Hacker的路线准备破解。大家有能力请支持正版软件。\n\n1.首先要有 Chrome浏览器 && 这是 Mac下的破解记录\n\n\n2.打开 https://www.crx4chrome.com/crx/109271/ 下载 Vysor的历史版本 1.9.3\n\n\n3.下载下来的是 crx格式的文件，把它从下载文件夹移动到另外放文件的地方。\n\n后缀改成 .zip格式，再解压下来成文件夹的格式\n\n\n4.Chrome浏览器打开输入 chrome://extensions/ 回车，打开开发者选项。选择\n\n加载已解压的扩展程序，将刚才解压的文件夹加载进来。\n\n\n5.\b打开 Vysor文件夹，搜索 uglify.js 文件。打开复制内容。打开 JS格式化代码网站\n\nhttp://tool.oschina.net/codeformat/js，复制代码转换，将转换好的代码复制进 uglify.js 文件。\n\n\n6.搜索 Account Management 关键词，将上面两行代码改成这样：\n\n![](/images/Vysor破解过程记录/001.png)\n\n\n\n\n7.搜索关键词 e.contentWindow._lm，将下面一行代码改成这样\n\n![](/images/Vysor破解过程记录/002.png)\n\n\n8.找到manifest.json这个文件\n\n    \"version\": \"1.7.2\" 改为  \"version\": \"99\"\n\n9.保存文件，Chrome里重启扩展程序。Launchpad里打开 Vysor发现已经变成专业版了。","tags":["原创","Hacker"],"categories":["开发"]},{"title":"What is unittest and how to write unit testing","url":"/2016/05/29/Unittest/","content":"\nUnit test is used for a module, a function or a class to test their validity.\nWe can write some test case for function abs() to test the validity of it:\n\n\n1.Input a positive number: 1, 3.2 or 0.6. We expect the return value to be the same as the input.\n\n2.Input a negative number: -1, -2,3 or -0.99. We expect the return value to be the opposite of the input.\n\n3.Input 0. We expect to return 0.\n\n<!-- more --> \n\n4.Input non-numeric types, such as None, [], {}. We expect a TypeError to be thrown.\n\nWe put the above test cases into a test module, it's a complete unit test.\nIf the unit test can be passed, which means that we tested this function to work properly.If the unit test does not pass, either the function has a bug, or the test condition is not entered correctly, we need fixes it to make unit tests pass.\n\nWhat are the benefits of unit testing? Imagine if we modified the abs () source code, we only need to run the unit tests again, if the test passed it means our changes to the abs () function does not affect the original behavior. If the test does not pass, it means that our changes have problems, we need to modify the code or modify the test.\n\nNext, we actually write code to illustrate the unit test.\n\n\n## abs.py\n\n\tdef abs(x):\n\n\t\tif not isinstance(x, (int, float)):\n\t\traise TypeError('bad operand type')\n\n\t\tif x >= 0:\n\t\t\treturn x\n\t\telse:\n\t\t\treturn -x\n\nThis is a python file, which defines an abs () function that takes an absolute value. \n\nOpen Terminal, cd into the folder where the abs.py file is located. Input python and press Enter to enter python's interactive programming environment：\n\n\t$ cd /Users/hisoft/Desktop/Unittest\n\t$ python\n\tPython 2.7.11 (default, Jan 22 2016, 08:29:18) \n\t[GCC 4.2.1 Compatible Apple LLVM 7.0.2 (clang-700.1.81)] on darwin\n\tType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n\nNow imput the 'import abs' on the Termanal and press to enters the module name abs there.\nWe use abs.abs (-5) to invoking the function in the module to find the absolute value of -5.\nThis part of the python can refer to the [official documents](https://docs.python.org/2.7/tutorial/modules.html).\n\n\t>>> import abs\n\t>>> abs.abs(-5)\n\t5\t\n\n\n## abs_test.py\n\nNow let's write the unit test for the abs function. We use the Python's unittest module, abs_test.py is like this:\n\n\timport unittest\n\n\tfrom abs import abs\n\n\tclass UnitTestDemo(unittest.TestCase):\n\n\t\tdef setup(self):\n\t\t\tprint('setUp...')\n\n\t\tdef tearDown(self):\n\t\t\tprint ('tearDoen...')\n\n\t\tdef test_case1(self):\n\n\t\t\tself.assertEqual(abs(1), 1)\n\t\t\tself.assertEqual(abs(-1), 1)\n\t\t\tself.assertEqual(abs(0), 0)\n\n\t\tdef test_case2(self):\n\t\t\n\t\t\twith self.assertRaises(TypeError):\n\t\t\t\tabs('1')\n\t\t\t\n\tif __name__ == '__main__':\n    \tunittest.main()\n\nWe need to write a test class When we write unit tests, This is inherited from 'unittest.TestCase'.\nThe test method begins with test, There are test_case1 and test_case2. A method that does not start with test is not considered a test method and will not be executed when tested.\n\n\n##Run the unit test\nNow we can run unit tests. To the end of the abs_test.py with two lines of code：\n\n\tif __name__ == '__main__':\n    \tunittest.main()\n\nThe two lines of code means that this script has been completed，we can run it directly：\n\n\tpython abs_test.py\n\n\nThere are two methods in the unit test script setUp() and tearDown(), They will invoking before and after each test method execute.\n\n\n\n\n\n","tags":["原创","技术"],"categories":["开发"]}]